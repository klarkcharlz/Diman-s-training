"""
1. Типы данных
	- не изменяемые
		- строки
		- числа int и float
		- кортежи
			- почему кортеж меньше весит чем список
		- фрозенсет
		- бул
		- complex

	- Изменяемые
		- списки
		- словари
			- алгоритм разрешения коллизий в словарях
		- множества

	- Рассказать о каждом типе данных
	- когда какой лучше использовать
	- интернирование
	- популярные методы
"""

# всё объект
a = 3
print(type(a))  # тип объекта
print(dir(a))  # список методов и атрибутов
print(a.bit_length())

# не изменяемые
b = 33  # int
c = 33.22  # float

d = "Dsdfdsf"  # str
t = (1, 2, 3)  # tuple
fs = frozenset([1, 2, 3, 3, 3, 4, 5, 5, 5, 5, 1, 1])  # frozenset
print(fs)
e = True  # bool
h = complex(2, 3)
print(f"Комплексное число: {h}")

# изменяемые
l = [1, 2, 3]
dic = {"a": 123}
se = {1, 2, 3}

value1 = 33
print(f"ID числа до изменения: {id(value1)}")
value1 += 1
print(f"ID числа после изменения: {id(value1)}")

print(f"ID списка до изменения: {id(l)}")
l.append(123)
print(f"ID списка после изменения: {id(l)}")

# Массив - кортеж или список
# кортеж - не изменяемая коллекция, список - изменяемая
# Когда что лучше использовать ?
# 1. Защита от дурака
# 2. Кортежи меньше весят в памяти

s1 = {1, 2, 3}
print(s1)
s1.add(4)
print(s1)
s1.add(1)
print(s1)

# множества хранят уникальные данные
# сет можно изменять, фрозенсет нет
# - быстрая проверка на вхождение

# Словари и множества это хеш таблица.

# популярные методы у каждого типа

# интернирование. Числа, кортежи, строки
aa = 3
bb = 3
print(id(aa))
print(id(bb))


av = 3 ** 321
bv = 3 ** 321
print(id(av))
print(id(bv))

ll1 = [1]
ll2 = [1]
print(id(ll1))
print(id(ll2))


aaa = 33
bbb = aaa
print(bbb)
bbb += 1
print(bbb)
print(aaa)

lll1 = [1]
lll2 = lll1

lll2.append(3)
lll2.append(4)
lll2.append(5)
print(lll2)
print(lll1)


lll2 = lll1[:]
lll2 = lll1.copy()
lll2 = list(lll1)
